# топ способы:

# a = int(input()) # task 4, операция unpacking arguments
# b = int(input())
# c = int(input())
# d = int(input())
# print('\t', *range(c, d + 1), sep='\t')
# for i in range(a, b + 1):
#     print(i, *range(i * c, (i * d) + 1, i), sep='\t')
# *range это операция unpacking arguments
# https://www.geeksforgeeks.org/packing-and-unpacking-arguments-in-python/﻿

# x = [x for x in range(int(input()),int(input()) + 1) if x % 3 == 0] # task  5: с помощью list comprehension внесли
# print(sum(x)/len(x)) # в список те значения х, которые удовлетворяют условию (деление на 3 без остатка)

# 1:--------------- # task 9 "обыграли выход за предела массива слайсом в "-"
# a=[int(i) for i in input().split()]
# if len(a)>1:
#     for i in range(len(a)):
#         print(a[i-1]+a[i+1-len(a)])
# else:
#     print(a[0])

# 2:--------------- # task 9 "обыграли выход за предела массива с помощью "остатка от деления" % первый выход
# src = [int(i) for i in input().split()]                                          # за пределы массива даст "0"
# if len(src) == 1:
#     print(src[0])
# else:
#     [print( src[i-1] + src[(i+1) % len(src)] ,end=' ') for i in range(len(src))]

# 3:--------------- # task 10 "использование set(набор), чтобы убрать повторяющиеся элементы и не выводи одно и тоже несколько раз"
# ls = [int(i) for i in input().split()]
# for i in set(ls): # set (набор) убирает все повторяющиеся элементы
#     if ls.count(i) > 1: # i принимает аргументы, из набора сет. Т.е. в i нет повторяющиеся значений
#         print(i, end=' ')

# 3:--------------- # task 12 "использование и enumerate и list comprehension"
# n = int(input())
# [str(i) for x, i in enumerate(list(i for i in range(1, n + 1) for j in range(i)), 1) if x <= n]


# ================================================================================================================================
# task 1:
# Напишите программу, которая считывает со стандартного ввода целые числа, по одному числу в строке,
# и после первого введенного нуля выводит сумму полученных на вход чисел.

# my decision:
# i = 1
# a = 0
# while i != 0:
#     i = int(input())
#     a += i
# print(a)

# best decisions:
# 1:---------------
# ================================================================================================================

# task 2:
# Программа должна считывать размеры команд (два положительных целых числа a и b, каждое число вводится
# на отдельной строке) и выводить наименьшее число d, которое делится на оба этих числа без остатка.

# my decision:
# a = int(input())
# b = int(input())
# c = max(a, b)
# while (c % a != 0) or (c % b != 0):
#     c = c + 1
# print(c)

# best decisions:
# 1:---------------
# a = int(input())
# # b = int(input())
# # d = a
# # while d % b:
# #     d += a
# # print(d)
# ================================================================================================================

# task 3:
# Напишите программу, которая считывает целые числа с консоли по одному числу в строке.
# Для каждого введённого числа проверить:
# если число меньше 10, то пропускаем это число;
# если число больше 100, то прекращаем считывать числа;
# в остальных случаях вывести это число обратно на консоль в отдельной строке.

# my decision:

# a = 1
# while a <= 100:
#     a = int(input())
#     if a >= 10 and a <= 100:
#         print(a)
#     elif a < 10:
#         continue
#     else:
#         break

# best decisions:

# 1:---------------

# ================================================================================================================

# task 4:
# Напишите программу, на вход которой даются четыре числа a a a, b b b, c c c и d d d, каждое в своей строке.
# Программа должна вывести фрагмент таблицы умножения для всех чисел отрезка [a;b] на все числа отрезка [c;d].
# Числа a, b, c и d являются натуральными и не превосходят 10, a≤b, c≤d.

# my decision:

# a = int(input())
# # b = int(input())
# # c = int(input())
# # d = int(input())
# # print(" ", end="")
# # for i in range(c, d + 1):
# #     print(i, end="\t")
# # print()
# # for i in range(a, b + 1):
# #     print(i, end=" ")
# #     for j in range(c, d + 1):
# #         print(j * i, end="\t")
# #     print()

# best decisions:

# 1:---------------
# a, b, c, d = (int(input()) for x in range(4))
# print('', *range(c,d+1), sep='\t')
# for x in range(a, b+1):
#     print(x, *[y*x for y in range(c, d+1)], sep='\t')

# 2:---------------
# a = int(input())
# b = int(input())
# c = int(input())
# d = int(input())
# print('\t', *range(c, d + 1), sep='\t')
# for i in range(a, b + 1):
#     print(i, *range(i * c, (i * d) + 1, i), sep='\t')
# *range это операция unpacking arguments
# https://www.geeksforgeeks.org/packing-and-unpacking-arguments-in-python/﻿

# ================================================================================================================


# task 5:
# Напишите программу, которая считывает с клавиатуры два числа a и b , считает и выводит на консоль среднее
# арифметическое всех чисел из отрезка [a;b], которые делятся на 3.
# В приведенном ниже примере среднее арифметическое считается для чисел на отрезке [−5;12].
# Всего чисел, делящихся на 3, на этом отрезке 6:  -3, 0, 3, 6, 9, 12. Их среднее арифметическое равно 4.5

# my decision:
# a = int(input())
# b = int(input())
# s = 0
# d = 0
# for i in range(a, b + 1):
#     if i % 3 == 0:
#         s += i
#         d += 1
# print(s / d)

# best decisions:

# 1:---------------
# a, b = int(input()), int(input())
# a += -a % 3
# b -= b % 3
# print((a + b) / 2)
# мы находим ближайшие к границам отрезка числа a и b, которые делятся на 3. Я не знаю, как это можно доказать
# математически, у нас есть числа -3,0,3,6,9,12 (первый пример [-5,12])  - и мы должны найти их середину.
# Стоит отметить, что в этом списке нет повторов и между числами одинаковое расстояние => мы должны найти середину
# этого списка. Что можно сделать несколькими способами. Например сложить все числа и разделить на их количество или
# поступить так же, но уже с двумя границами (a и b), что будет явно быстрее.

# 2:---------------
# x = [x for x in range(int(input()),int(input()) + 1) if x % 3 == 0]
# print(sum(x)/len(x))

# ================================================================================================================

# task 6:
# Напишите программу, которая вычисляет процентное содержание символов G (гуанин) и C (цитозин)
# в введенной строке (программа не должна зависеть от регистра вводимых символов).
# Например, в строке "acggtgttat" процентное содержание символов G и C равно 4/10⋅100=40.0
# , где 4 - это количество символов G и C,  а 10 - это длина строки.

# my decision:
# n = input()
# n = n.lower()
# i = n.count("c")
# j = n.count("g")
# l = len(n)
# print((((i+j)/l)*100))

# best decisions:

# 1:---------------
# s = input().upper()
# print((s.count('G') + s.count('C'))/len(s) * 100)

# 2:---------------
# s = input()
# c = 0
# for ch in s:
#     if ("gcGC".find(ch) != -1):
#         c += 1
# print(c / len(s) * 100)


# ================================================================================================================

# task 7:
# Кодирование осуществляется следующим образом:
# s = 'aaaabbсaa' преобразуется в 'a4b2с1a2', то есть группы одинаковых символов исходной строки заменяются
# на этот символ и количество его повторений в этой позиции строки.
# Напишите программу, которая считывает строку, кодирует её предложенным алгоритмом и выводит закодированную
# последовательность на стандартный вывод. Кодирование должно учитывать регистр символов.

# my decision:

# n = input()
# b = n[0]
# s = 0
# for i in range(len(n)):
# 	if b == n[i]:
# 		s += 1
# 	else:
# 		print(b, s, sep="", end="")
# 		b = n[i]
# 		s = 1
# 	if i == (len(n) - 1):
# 		print(b, s, sep="", end="")

# best decisions:

# 1:---------------
# То действие, которые является особым, т.е. прекращается последовательность - можно обрабатывать в условии.
# А накручивать счётчик при прохождении символов - это "нормальное" поведение программы, поэтому его можно выполнять
# без дополнительных условных блоков.

# genome = input() + ' '
# s = 0
# n = genome[0]
# for i in genome:
#     if n != i:
#         print(n + str(s), end='')
#         s = 0
#         n = i
#     s += 1

# 2:---------------
# dna = input()                    # считываем строку
# print(dna[0],end='')             # выводим первый символ
# cnt = 1                          # счетчик символов на единице
# for i in range(0,len(dna)-1):    # итератор проходит по всем индексам символов кроме предпоследнего
#     if dna[i] == dna[i+1]:       # сравниваем символ по текущему индексу со следующим
#         cnt+=1                   # если символы одинаковые, то увеличиваем счетчик
#     else :
#         print(cnt,end='')        # если разные, то выводим значение счетчика
#         print(dna[i+1],end='')   # выводим следующий символ
#         cnt = 1                  # счетчик текущего символа на единице
# print(cnt)                       # в конце распечатываем значение счетчика последнего символа

# 3:-------------------
# strii = input() + ' '
# br, cnt = strii[0], 0
# for s in strii:
#     if s != br:
#         print(br + str(cnt), end='')
#         br, cnt = s, 0
#     cnt += 1

# ================================================================================================================

# task 8:
# Напишите программу, на вход которой подается одна строка с целыми числами.
# Программа должна вывести сумму этих чисел.
# Используйте метод split строки.

# my decision:
# n = [int(i) for i in input().split()]
# s = 0
# for j in n:
#     s += j
# print(s)

# best decisions:

# 1:---------------
# print(sum(int(i) for i in input().split()))

# 2:---------------
# print(eval(input().replace(' ','+')))

# ================================================================================================================


# task 9:
# Напишите программу, на вход которой подаётся список чисел одной строкой.
# Программа должна для каждого элемента этого списка вывести сумму двух его соседей. Для элементов списка, являющихся
# крайними, одним из соседей считается элемент, находящий на противоположном конце этого списка.
# Например, если на вход подаётся список "1 3 5 6 10", то на выход ожидается список "13 6 9 15 7" (без кавычек).
# Если на вход пришло только одно число, надо вывести его же.
# Вывод должен содержать одну строку с числами нового списка, разделёнными пробелом.

# my decision:
# n = [int(i) for i in input().split()]
# if len(n) == 1:
#     print(n[0])
# else:
#     for i in range(len(n)):
#         if i == (len(n) - 1):
#             print(n[i - 1] + n[0])
#         else:
#             print(n[i - 1] + n[i + 1], end=" ")

# best decisions:

# 1:---------------
# a=[int(i) for i in input().split()]
# if len(a)>1:
#     for i in range(len(a)):
#         print(a[i-1]+a[i+1-len(a)])
# else:
#     print(a[0])

# 2:---------------
# src = [int(i) for i in input().split()]
# if len(src) == 1:
#     print(src[0])
# else:
#     [print( src[i-1] + src[(i+1) % len(src)] ,end=' ') for i in range(len(src))]
# выражение src[(i+1) % len(src)] на выходе для src = [1, 3, 5, 6, 10] даст [3, 5, 6, 10, 1]
# потому, что (i+1) % len(src) даёт 1 2 3 4 0
# т.е. таким образом 0й элемент оказывается в конце списка (как будто повернули циферблат)
# таким образом если при обращении к i+1 случится выход за границу диапазона для последнего элемента
# то при обращении к (i+1) % len(src) элементу выхода не произойдет
# поэтому складывая -1й элемент с [(i+1) % len(src)]-тым элементом
# мы выполним условие найти сумму предыдущего и следующего элементов
# [print( src[(i+1) % len(src)]) for i in range(len(src))]

# 3:---------------
# Заменил конструкцию if-else на истину-ложь. Суть в том, что каждый элемент списка-это сумма двух слагаемых.
# Если мы прогоним список с одним элементом (лен()=1), значение элемента удвоится ((и-1)+(и+1))=2и.
# Тогда от одного из слагаемых можно избавиться, чтобы и на входе и на выходе было одно и то же число "и".
# Для этого я умножил это слагаемое на некоторое выражение, которое в случае одноэлементного списка принимает
# значение 0, а во все остальных-1. То есть нужна некая функция, принимающая одно из двух возможных значений: 0 и 1.
# А пара Истина/Ложь как раз интерпретируется как 1/0. И если список состоит из 1 элемента, то выражение b==1 истинно и
# равно 1, когда при всех прочих вариантах оно равно 0.

# a=[int(i) for i in input().split()]
# b=len(a)
# [print(int(a[i-1])*(1-(b==1))+int(a[(i+1)%b]), end=' ') for i in range(b)]


# ================================================================================================================

# task 10:
# Напишите программу, которая принимает на вход список чисел в одной строке и выводит на экран в одну строку значения,
# которые повторяются в нём более одного раза.
# Для решения задачи может пригодиться метод sort списка.
# Выводимые числа не должны повторяться, порядок их вывода может быть произвольным.

# my decision:
# numbers = [int(i) for i in input().split()]
# search = []
# for number in numbers:
#     if (numbers.count(number) > 1) and (number not in search):
#         print(number, end=' ')
#         search.append(number)

# best decisions:

# 1:---------------
# a, b = [int(i) for i in input().split()], []
# for i in a:
#     if a.count(i) > 1 and b.count(i) == 0:
#         b.append(i)
# for i in b:
#     print(i, end=" ")

# 1:---------------
# ls = [int(i) for i in input().split()]
# for i in set(ls): # set (набор) убирает все повторяющиеся элементы
#     if ls.count(i) > 1: # i принимает аргументы, из набора сет. Т.е. в i нет повторяющиеся значений
#         print(i, end=' ')

# 1:---------------
# str = [int(i) for i in input().split()]
# ans = []
# [ans.append(x) for x in str if x not in ans and str.count(x) > 1]
# print(*ans)

# ================================================================================================================

# task 11:
# Напишите программу, которая считывает с консоли числа (по одному в строке) до тех пор, пока сумма введённых чисел
# не будет равна 0 и сразу после этого выводит сумму квадратов всех считанных чисел.
# Гарантируется, что в какой-то момент сумма введённых чисел окажется равной 0, после этого считывание
# продолжать не нужно.
# В примере мы считываем числа 1, -3, 5, -6, -10, 13; в этот момент замечаем, что сумма этих чисел равна
# нулю и выводим сумму их квадратов, не обращая внимания на то, что остались ещё не прочитанные значения

# my decision:
# my_list = [int(input())]
# while sum(my_list) != 0: # можно убрать условие, т.к. когда сумма будет равно 0, это аналогично False
#     my_list.append(int(input()))
# print(sum([i ** 2 for i in my_list]))

# best decisions:

# ================================================================================================================

# task 12:
# Напишите программу, которая выводит часть последовательности 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 ... (число повторяется
# столько раз, чему равно). На вход программе передаётся неотрицательное целое число n — столько элементов
# последовательности  должна отобразить программа. На выходе ожидается последовательность чисел, записанных через
# пробел в одну строку.
# Например, если n = 7, то программа должна вывести 1 2 2 3 3 3 4.

# my decision:
# n = int(input())
# p = []
# for i in range(1, n + 1):
#     # p += [i for a in range(i)]
#     p += [i] * i
#     if len(p) >= n:  # добавил, чтобы не было огромного списка, но он создает не ровно нужное кол-во, а больше
#         break
# print(*(p[:n]))
# print(' '.join(map(str, p)))

# best decisions:
# 1:---------------
# x = int(input())  # у последовательности из задания есть формула: a(n)=floor(1/2+sqrt(2n))
# print(*[int(1 / 2 + (2 * n) ** (1 / 2)) for n in range(1, x + 1)])

# 1:---------------
# n = int(input())
# print(*[i for i in range(1, n + 1) for j in range(i)][:n])

# 1:---------------
# n = int(input())
# [str(i) for x, i in enumerate(list(i for i in range(1, n + 1) for j in range(i)), 1) if x <= n]

# ================================================================================================================

# task 13:
# Напишите программу, которая считывает список чисел lst из первой строки и число x  из второй строки,
# которая выводит все позиции, на которых встречается число x  в переданном списке lst.
# Позиции нумеруются с нуля, если число x не встречается в списке, вывести строку "Отсутствует"
# Позиции должны быть выведены в одну строку, по возрастанию абсолютного значения.

# my decision:
# 1:---------------
# n_list = [int(i) for i in input().split()]
# number = int(input())
# flag = 0
# for i in range(len(n_list)):
#     if n_list[i] == number:
#         print(i, end=' ')
#         flag = 1
# if flag == 0:
#     print('Отсутствует')

# 2:--------------- does't work
# n_list = [int(i) for i in input().split()]
# number = int(input())
# n = -1
# for i in n_list:
#     n = n_list[n + 1:].index(number)
#     if n != -1:
#         print(n, end=' ')
#     else:
#         print('Отсутствует')
#         break


# best decisions:
# 1:--------------- почти как мой, только сначала идет проверка на отсутствие -> не нужен флаг
# ll = [int(i) for i in input().split()]
# x = int(input())
# if x not in ll:
#     print('Отсутствует')
# else:
#     for i in range(len(ll)):
#         if ll[i] == x:
#             print(i, end=' ')

# 2:--------------- использовали энумерате, но создали еще один список изи None элементов, что плохо для памяти
# numbers = [int(i) for i in input().split()]
# needed = int(input())
# if needed not in numbers:
#     print("Отсутствует")
# else:
#     [print(i, end=" ") for i, x in enumerate(numbers) if x == needed]

# 3:--------------- решение в одну строку с помощью list comprehension
# l, n = [int(i) for i in input().split()], int(input())
# print(*[x for x in range(len(l)) if l[x]==n] if n in l else ["Отсутствует"])
# сначала идет проверка правого условия, если выполнятеся, то выполянет список, в котором еще одно узловие и цикл

# ================================================================================================================

# task 14:
# Напишите программу, на вход которой подаётся прямоугольная матрица в виде последовательности строк,
# заканчивающихся строкой, содержащей только строку "end" (без кавычек)
# Программа должна вывести матрицу того же размера, у которой каждый элемент в позиции i, j равен сумме элементов
# первой матрицы на позициях (i-1, j), (i+1, j), (i, j-1), (i, j+1). У крайних символов соседний элемент находится
# с противоположной стороны матрицы.
# В случае одной строки/столбца элемент сам себе является соседом по соответствующему направлению.

# my decision:
# 1-----------------------------------
# [mtx.append([int(new)]) if new != 'end' else break for new in input().split()] # does't work bcz break can't be here
# mtx = []
# while mtx == [] or mtx[-1] != ['end']:
#     mtx += [[i for i in input().split()]]
# mtx = [[int(lis) for lis in lists] for lists in mtx[:-1]]
# new_mtx = [i.copy() for i in mtx]  # i[:]  # or i.copy(), нужно копировать каждую строку отдельно, иначе он создает
# # ссылки на строки, а не копирует их
# # в этом цикле меняем значения по строкам
# for row in range(len(mtx)):  # перебор по строкам. длина матрицы == кол-во сток
#     for col in range(len(mtx[row])):  # перебор чисел в строке
#         new_mtx[row][col] = mtx[row][col + 1 - len(mtx[row])] + mtx[row][col - 1]
# # в этом цикле меняем значения по столбцам
# for col in range(len(mtx[0])):  # берем количество столбцов
#     for row in range(len(mtx)):  # берем строку
#         new_mtx[row][col] += mtx[row + 1 - len(mtx)][col] + mtx[row - 1][col]
# [print(*row) for row in new_mtx]
# 1----------------------------------- можно было не делать 2 цикла, а сразу суммировать все числа вокруг
# mtx = []
# while mtx == [] or mtx[-1] != ['end']:
#     mtx += [[i for i in input().split()]]
# mtx = [[int(lis) for lis in lists] for lists in mtx[:-1]]
# new_mtx = [i.copy() for i in mtx]  # i[:]  # or i.copy(), нужно копировать каждую строку отдельно, иначе он создает
#
# for row in range(len(mtx)):  # перебор по строкам. длина матрицы == кол-во сток
#     for col in range(len(mtx[row])):  # перебор чисел в строке
#         new_mtx[row][col] = mtx[row][col + 1 - len(mtx[row])] + mtx[row][col - 1] + mtx[row + 1 - len(mtx)][col] + \
#                             mtx[row - 1][col]
# [print(*row) for row in new_mtx]


# best decisions ======================================================:
# 1:---------------

# ================================================================================================================

# task 15:
# Выведите таблицу размером n×n n \times n n×n, заполненную числами от 1  до n2 n^2 n2 по спирали,
# выходящей из левого верхнего угла и закрученной по часовой стрелке, как показано в примере (здесь n=5):

# my decision:
# n = int(input())
# n_count = n  # счетчик для перехода из строки в столбец
# i = 1  # create a counter of steps
# step_2 = 1  # счетчик четных шагов, чтобы идти в другую сторону (отрицательную) массива
# row = 0
# col = 0
# mtr = [[0] * n for i in range(n)]  # сгенерили n мерный массив из нулей
# while i < n ** 2:  # пока не дошли до квадрата введенного значения, будем делать цикл
#     # цикл по значениям в строке
#     while i < n_count:  # пока не дошли до счетчка перехода из строки в столбец
#         mtr[row][col] = i  # вставляем цифру в массив
#         if step_2 % 2 == 0:  # если шаг четный, значит надо идти в обратную сторону массива
#             col -= 1
#         else:
#             col += 1  # инкрементируем значение столбца
#         i += 1  # инкрементируем цифру для вставки
#     # row, col = col, row  # меняем значение строки и столбца местами
#     n_count += n - step_2  # увеличили счестчик перехода на саму себя -1, т.к. после прохода по строке уменьшилось расстояние для столбца
#     # цикл по значениям в столбце, на котором останавился прошлый цикл
#     while i < n_count:  # пока не дошли до счетчка перехода из строки в столбец
#         mtr[row][col] = i  # вставляем цифру в массив
#         if step_2 % 2 == 0:  # если шаг четный, значит надо идти в обратную сторону массива
#             row -= 1
#         else:
#             row += 1  # инкрементируем значение строки
#         i += 1  # инкрементируем цифру для вставки
#     n_count += n - step_2
#     step_2 += 1
# mtr[row][col] = i  # вставляем последний элемент
# [print(*row) for row in mtr]

# 2=====================================================
# x = int(input())
#
# massive_x = [[0] * x for i in range(x)]
#
# row, col, step, counter = 0, 0, 0, 1
#
# massive_x[x // 2][x // 2] = x ** 2  # ставим в центр квадрат числа
#
# for i in range(x * 2):  # от 1 до (x-1) счетчик (столько у нас шагов выходит для заполнения массива)
#     for col in range(col, x - step):    # заполняем крайнюю верхнюю строку
#         massive_x[row][col] = counter
#         counter += 1
#
#     row += 1
#
#     for row in range(row, x - step):    # заполняем крайний правый столбец
#         massive_x[row][col] = counter
#         counter += 1
#
#     col -= 1
#
#     for col in range(col, -1 + step, -1):    # заполняем крайнюю нижнюю строку
#         massive_x[row][col] = counter
#         counter += 1
#
#     row -= 1
#
#     for row in range(row, step, -1):    # заполняем крайний правый столбец
#         massive_x[row][col] = counter
#         counter += 1
#
#     step += 1
#     col += 1
#
# for i in range(x):
#     print(*massive_x[i])

# best decisions=========================================:
# 1:---------------
# n = int(input())
# t = [[0] * n for i in range(n)]
# i, j = 0, 0
# for k in range(1, n * n + 1):
#     t[i][j] = k
#     if k == n * n: break
#     if i <= j + 1 and i + j < n - 1:
#         j += 1
#     elif i < j and i + j >= n - 1:
#         i += 1
#     elif i >= j and i + j > n - 1:
#         j -= 1
#     elif i > j + 1 and i + j <= n - 1:
#         i -= 1
# for i in range(n):
#     print(*t[i])

# 2:---------------
# n = int(input())
# x, y, dx, dy, m = 0, 0, 0, 1, [[0] * n for i in range(n)]
# for i in range(n * n):
#     m[x][y] = str(i + 1)
#     if x + dx >= n or x + dx < 0 or y + dy >= n or y + dy < 0 or m[x + dx][y + dy]:
#         dx, dy = dy, -dx
#     x, y = x + dx, y + dy
# print("\n".join([" ".join(i) for i in m]))

# 3:---------------
# # n - размерность матрицы n x n
# # mat - результирующая матрица
# # st - текущее значение-счетчик для записи в матрицу
# # m - коеффициент, используемый для заполнения верхней
# # матрицы последующих витков, т.к. одномерные матрицы
# # следующих витков имеют меньше значений
# n = int(input())
# mat = [[0] * n for i in range(n)]
# st, m = 1, 0
# # Заранее присваиваю значение центральному элементу
# # матрицы
# mat[n // 2][n // 2] = n * n
# for v in range(n // 2):
#     # Заполнение верхней горизонтальной матрицы
#     for i in range(n - m):
#         mat[v][i + v] = st
#         st += 1
#         # i+=1
#     # Заполнение правой вертикальной матрицы
#     for i in range(v + 1, n - v):
#         mat[i][-v - 1] = st
#         st += 1
#         # i+=1
#     # Заполнение нижней горизонтальной матрицы
#     for i in range(v + 1, n - v):
#         mat[-v - 1][-i - 1] = st
#         st += 1
#         # i+=1
#     # Заполнение левой вертикальной матрицы
#     for i in range(v + 1, n - (v + 1)):
#         mat[-i - 1][v] = st
#         st += 1
#         # i+=1
#     # v+=1
#     m += 2
# # Вывод результата на экран
# for i in mat:
#     print(*i)

# Заполенине массива по спирали из центра================================:
# x = int(input())
#
# massive_x = [[0] * x for i in range(x)]
#
# row, col = x // 2, x // 2
# step, counter, l_x = 2, 1, x - 1
#
# massive_x[x // 2][x // 2] = 0  # ставим в центр квадрат числа
#
# for tic in range(x * 2):  # от 1 до (x-1) счетчик (столько у нас шагов выходит для заполнения массива)
#
#     for i in range(1, step):
#         massive_x[row][col - i] = counter
#         counter += 1
#
#     col = col - (step - 1)
#     row += 1
#
#     for i in range(1, step):
#         massive_x[row + i][col] = counter
#         counter += 1
#
#     row = row + (step - 1)
#     col += 1
#     step += 1
#
#     for i in range(1, step):
#         massive_x[row][col + i] = counter
#         counter += 1
#
#     col = col + (step - 1)
#     row -= 1
#
#     for i in range(1, step):
#         massive_x[row - 1][col] = counter
#         counter += 1
#
#     row = row - (step - 1)
#     col -= 1
#     step += 1
#
# for i in range(x):
#     print(*massive_x[i])
